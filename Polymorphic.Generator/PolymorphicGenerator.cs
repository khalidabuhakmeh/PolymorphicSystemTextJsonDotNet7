using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Polymorphic.Generator;

[Generator]
public class PolymorphicGenerator : ISourceGenerator
{
    public const string JsonDerivedTypesAttributeName = "JsonDerivedTypes";

    public void Initialize(GeneratorInitializationContext context)
    {
    }

    public void Execute(GeneratorExecutionContext context)
    {
        context.AddSource("JsonDerivedTypeAttribute.generated.cs",
/* language=C# */
            $@"namespace Polymorphic.Generator;

[AttributeUsage(AttributeTargets.Class)]
public class {JsonDerivedTypesAttributeName} : Attribute {{ }}");

        var classesWithAttribute = context.Compilation.SyntaxTrees
            .SelectMany(st => st
                .GetRoot()
                .DescendantNodes()
                .OfType<TypeDeclarationSyntax>()
                .Where(r => r.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword))
                            && r.AttributeLists
                                .SelectMany(al => al.Attributes)
                                .Any(a => a.Name.GetText().ToString() == JsonDerivedTypesAttributeName)
                )
            ).ToList();

        foreach (var baseClass in classesWithAttribute)
        {
            var sb = new StringBuilder("// <auto-generated/>\n");
            var derived = context.Compilation.SyntaxTrees
                .SelectMany(st => st
                    .GetRoot()
                    .DescendantNodes()
                    .OfType<TypeDeclarationSyntax>()
                    .Where(r => r.BaseList?.Types.Any(b => b.Type.GetText().ToString() == baseClass.Identifier.Text) ==
                                true))
                .ToList();

            if (derived.Any())
            {
                sb.AppendLine($"namespace {GetNamespace(baseClass)};\n");

                foreach (var d in derived)
                {
                    sb.AppendLine(
                        $"[System.Text.Json.Serialization.JsonDerivedType(typeof({GetNamespace(d)}.{d.Identifier}), typeDiscriminator: \"{d.Identifier.Text.ToLowerInvariant()}\")]");
                }

                sb.Append($"{baseClass.Modifiers.ToFullString()}{baseClass.Keyword.Text} {baseClass.Identifier} {{ }}");
            }

            context.AddSource($"{baseClass.Identifier.Text}.generated.cs", sb.ToString());
        }
    }

    // https://andrewlock.net/creating-a-source-generator-part-5-finding-a-type-declarations-namespace-and-type-hierarchy/
    static string GetNamespace(BaseTypeDeclarationSyntax syntax)
    {
        // If we don't have a namespace at all we'll return an empty string
        // This accounts for the "default namespace" case
        string nameSpace = string.Empty;

        // Get the containing syntax node for the type declaration
        // (could be a nested type, for example)
        SyntaxNode? potentialNamespaceParent = syntax.Parent;

        // Keep moving "out" of nested classes etc until we get to a namespace
        // or until we run out of parents
        while (potentialNamespaceParent != null &&
               potentialNamespaceParent is not NamespaceDeclarationSyntax
               && potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
        {
            potentialNamespaceParent = potentialNamespaceParent.Parent;
        }

        // Build up the final namespace by looping until we no longer have a namespace declaration
        if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
        {
            // We have a namespace. Use that as the type
            nameSpace = namespaceParent.Name.ToString();

            // Keep moving "out" of the namespace declarations until we 
            // run out of nested namespace declarations
            while (true)
            {
                if (namespaceParent.Parent is not NamespaceDeclarationSyntax parent)
                {
                    break;
                }

                // Add the outer namespace as a prefix to the final namespace
                nameSpace = $"{namespaceParent.Name}.{nameSpace}";
                namespaceParent = parent;
            }
        }

        // return the final namespace
        return nameSpace;
    }
}